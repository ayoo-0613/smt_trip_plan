from z3 import Int, If
    from attr_search import AttractionSearch
    
    # Run AttractionSearch to get attraction info for all cities
    attraction_info = AttractionSearch.run_for_all_cities(cities)
    
    # Set 'attraction_in_which_city' variables for 5 attractions (1 per day)
    variables['attraction_in_which_city'] = [Int('attraction_' + str(i)) for i in range(5)]
    
    # For each attraction, assert it to be either current city or next city based on transportation arrivals time
    for i, variable in enumerate(variables['attraction_in_which_city']):
        s.assert_and_track(variable == If(arrives[i] > 18, cities[i+1], cities[i]), 'attraction in which city')
    
    # Set 'attraction_index' variables for 5 attractions (1 per day)
    variables['attraction_index'] = [Int('attraction_{}_index'.format(i)) for i in range(5)]
    
    # For each attraction index, get specific length info based on attraction in which city variable
    for i, variable in enumerate(variables['attraction_index']):
        attraction_list_length = AttractionSearch.get_info(attraction_info, variables['attraction_in_which_city'][i])
        s.assert_and_track(Implies(variables['attraction_in_which_city'][i] != -1, And(variable >= 0, variable < attraction_list_length)), 'valid attraction index')
        
    # Ensure attractions in same city are not repeated
    for i in range(len(variables['attraction_index'])):
        for j in range(i):
            s.assert_and_track(Implies(And(variables['attraction_in_which_city'][i] != -1, variables['attraction_in_which_city'][i] == variables['attraction_in_which_city'][j]), 
                                     variables['attraction_index'][i] != variables['attraction_index'][j]), 'non repeating attraction index')
    
    # Check for unsaturation
    if s.check() == sat.UNSAT:
        print("Attraction constraints are not satisfiable")